// HTTP server with extended directory indices.
//
// The directory indices generated by this server feature:
// "download as archive" functionality,
// multi-file upload (form/drag-n-drop), and
// javascript managed upload with progress display.
package httpd

import (
	"archive/tar"
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/spf13/cobra"

	"go.pberndt.com/iwebd/util"
)

// Generate a TAR archive for a given directory
func archive(w http.ResponseWriter, r *http.Request) {
	directory := "./" + r.URL.Path[len("/.well-known/archive/"):]
	if strings.Contains(directory, "..") {
		http.Error(w, "Request for invalid path", 400)
		return
	}

	w.Header()["Content-Type"] = []string{"application/tar"}
	w.Header()["Content-Disposition"] = []string{"attachment; filename=\"directory.tar\""}

	archiveWriter := tar.NewWriter(w)
	_ = filepath.WalkDir(directory, func(path string, d os.DirEntry, err error) error {
		if d == nil || d.IsDir() {
			return nil
		}
		info, err := d.Info()
		if err != nil {
			fmt.Printf("Error copying %s: %v\n", path, err)
			return nil
		}
		if !info.Mode().IsRegular() && info.Mode().Type() != fs.ModeSymlink {
			return nil
		}
		header, err := tar.FileInfoHeader(info, "" /* link */)
		if err != nil {
			fmt.Printf("Error copying %s: %v\n", path, err)
			return nil
		}
		header.Name = path
		f, err := os.Open(path)
		if err != nil {
			fmt.Printf("Error copying %s: %v\n", path, err)
			return err
		}
		defer f.Close()
		archiveWriter.WriteHeader(header)
		if info.Mode().Type() == fs.ModeSymlink {
			return nil
		}
		io.Copy(archiveWriter, f)
		return nil
	})
	archiveWriter.Close()
}

// Manage the upload of a file
func upload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", 405)
		return
	}
	reader, err := r.MultipartReader()
	if err != nil {
		http.Error(w, "Invalid request", 400)
		return
	}
	part, err := reader.NextPart()
	if err != nil || part.FormName() != "path" {
		http.Error(w, "Invalid request", 400)
		return
	}
	builder := strings.Builder{}
	io.Copy(&builder, part)
	path := builder.String()

	var fileList []fileContentsFragment
	for {
		part, err := reader.NextPart()
		if err == io.EOF {
			break
		}
		if part.FormName() != "file" {
			continue
		}

		targetPath := filepath.Join(strings.TrimPrefix(path, "/"), part.FileName())
		if strings.Contains(targetPath, "..") {
			http.Error(w, "Invalid path", 400)
			return
		}

		handle, err := os.OpenFile(targetPath, os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			http.Error(w, "Couldn't open file for writing", 500)
			continue
		}
		_, err = io.Copy(handle, part)
		if err != nil {
			http.Error(w, "Failed to write file", 500)
			handle.Close()
			os.Remove(targetPath)
			// TODO Could keep file around for a while to allow resuming
			return
		}
		err = handle.Close()
		if err != nil {
			http.Error(w, "Failed to write file", 500)
			handle.Close()
			os.Remove(targetPath)
		}

		stat, _ := os.Stat(targetPath)
		headerGetter := func() []byte {
			var header [512]byte
			fp, err := os.Open(targetPath)
			if err != nil {
				return []byte{}
			}
			fp.Read(header[:])
			fp.Close()
			return header[:]
		}
		fileList = append(fileList, fileContentsFragment{
			Name:       part.FileName(),
			Link:       part.FileName(),
			Icon:       getIconURI(stat, headerGetter),
			Annotation: util.SizeToHumanReadableSize(stat.Size()),
		})
	}

	if strings.Contains(r.Header.Get("Accept"), "application/json") {
		out, _ := json.Marshal(fileList)
		w.Header()["Content-Type"] = []string{"application/json"}
		w.Write(out)
	} else {
		w.Header()["Location"] = []string{path}
		w.WriteHeader(307)
	}
}

// Launch a HTTP(S) server.
func Serve(cmd *cobra.Command, args []string) {
	useTls, _ := cmd.Flags().GetBool("tls")
	addr, _ := cmd.Flags().GetString("addr")
	auth, _ := cmd.Flags().Lookup("auth").Value.(*util.UserPass)
	readOnly, _ := cmd.Flags().GetBool("read-only")

	util.Log.Info("%s server starting", "http")

	m := http.NewServeMux()

	var tlsConfig *tls.Config
	if useTls {
		tlsConfig = &tls.Config{
			Certificates: []tls.Certificate{util.GenKeyPair()},
		}
	}
	s := &http.Server{
		Handler:   WithHttpLogging(WithAuth(m, auth)),
		TLSConfig: tlsConfig,
	}
	m.HandleFunc("/.well-known/icons/", ServeIcon)
	m.HandleFunc("/.well-known/archive/", archive)
	if !readOnly {
		m.HandleFunc("/.well-known/upload", upload)
	}
	m.Handle("/", http.FileServer(&fancyDirectoryIndex{http.Dir("./"), readOnly}))

	var defaultPort uint16
	if useTls {
		defaultPort = 443
	} else {
		defaultPort = 80
	}
	listener, err := util.GenListener(addr, defaultPort)
	if err != nil {
		util.Log.Error("Failed to spawn server: %v", err)
		return
	}

	util.ShowInterfaces(listener.Addr())

	if b, _ := cmd.Flags().GetBool("bonjour"); b {
		sq := util.RegisterBonjour("_http._tcp", []string{}, listener.Addr())
		defer sq.Shutdown()
	}

	quitNotifier := make(chan int)
	go func() {
		var err error
		if !useTls {
			err = s.Serve(listener)
		} else {
			err = s.ServeTLS(listener, "", "")
		}
		if err != nil && err != http.ErrServerClosed {
			util.Log.Error("Failure while serving: %v", err)
		}
		quitNotifier <- 0
	}()

	util.WaitToQuit(quitNotifier)

	ctx, _ := context.WithTimeout(context.Background(), 5*time.Second)
	s.Shutdown(ctx)
}
